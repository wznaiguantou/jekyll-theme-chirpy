---
layout: post
title:  "SpringBoot 源码解析(一)"
date:   2022-06-25 11:26:30 +0800
categories: Spring
---

# SpringBoot 启动源码解析(二)

## 1、前情回顾

上一期讲到了SpringBoot启动的基本过程，主要是SpringApplication的实例化、初始化以及ApplicationContext的基础生成过程，包含了Environment的准备、Context的准备，SpringBoot在启动过程中的基础型事件。



## 2、ApplicationContext-RefreshContext

这一篇，我们更进一步，来分析ApplicationContext在RefreshContext中所做的一些事情。
现在我们分析的内容是Spring的最核心的内容: spring-context-5.2.10.RELEASE.jar, 并不属于SpringBoot。所以有些扩展点站在SpringBoot的层面上其实我们反而不能去很好的扩展。

### 2.1 ApplicationContext的Diagrams

不难发现，我们在追踪到源码层时候，SpringBoot里用到的基本都是接口，换言之，其实在某一时刻，他已经提前创建好了对应的实例。

而本次我们分析的主要是AnnotationConfigServletWebApplicationContext. 因为我们引入的jar是 **spring-boot-starter-web**。

![AnnotationConfigServletWebApplicationContext](../../assets/img/spring/AnnotationConfigServletWebServerApplicationContext.png)

从上图可以看到，其实还挺复杂的，在类的组装、设计上，用到了很多基础设计原则。

### 2.2 Refresh Context

跟进源码，我们发现核心的内容就在**AbstractApplicationContext**, 其实Spring的团队也非常贴心的给了我们每个步骤的概要注释

```java
	@Override
	public void refresh() throws BeansException, IllegalStateException {
		// 加锁，防止
    synchronized (this.startupShutdownMonitor) {
			// Prepare this context for refreshing.
			prepareRefresh();

			// Tell the subclass to refresh the internal bean factory.
      // 得到一个刷新后的工厂
			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

			// Prepare the bean factory for use in this context.
      // 
			prepareBeanFactory(beanFactory);

			try {
				// Allows post-processing of the bean factory in context subclasses.
				postProcessBeanFactory(beanFactory);

				// Invoke factory processors registered as beans in the context.
				invokeBeanFactoryPostProcessors(beanFactory);

				// Register bean processors that intercept bean creation.
				registerBeanPostProcessors(beanFactory);

				// Initialize message source for this context.
				initMessageSource();

				// Initialize event multicaster for this context.
				initApplicationEventMulticaster();

				// Initialize other special beans in specific context subclasses.
				onRefresh();

				// Check for listener beans and register them.
				registerListeners();

				// Instantiate all remaining (non-lazy-init) singletons.
				finishBeanFactoryInitialization(beanFactory);

				// Last step: publish corresponding event.
				finishRefresh();
			}

			catch (BeansException ex) {
				if (logger.isWarnEnabled()) {
					logger.warn("Exception encountered during context initialization - " +
							"cancelling refresh attempt: " + ex);
				}

				// Destroy already created singletons to avoid dangling resources.
				destroyBeans();

				// Reset 'active' flag.
				cancelRefresh(ex);

				// Propagate exception to caller.
				throw ex;
			}

			finally {
				// Reset common introspection caches in Spring's core, since we
				// might not ever need metadata for singleton beans anymore...
				resetCommonCaches();
			}
		}
	}
```

#### 2.2.1 prepareRefresh

```java
    /**
     * Prepare this context for refreshing, setting its startup date and active flag as well as
     * performing any initialization of property sources.
     */
    protected void prepareRefresh() {
        // Switch to active.
        // 记录下时间
        this.startupDate = System.currentTimeMillis();
        //
        /** Flag that indicates whether this context is currently active. */
        // private final AtomicBoolean active = new AtomicBoolean();
        /** Flag that indicates whether this context has been closed already. */
        // private final AtomicBoolean closed = new AtomicBoolean();
        // 搞了2个变量，表示上下文目前处于激活状态
        this.closed.set(false);
        this.active.set(true);

        if (logger.isDebugEnabled()) {
            if (logger.isTraceEnabled()) {
                logger.trace("Refreshing " + this);
            } else {
                logger.debug("Refreshing " + getDisplayName());
            }
        }

        // Initialize any placeholder property sources in the context environment.
        // 这里是初始化servlet的一些属性 initServletPropertySources，个人的理解是在SpringBoot启动的时候我们是用不上的，
        // 因为上下文的实例已经明确好了。而在这里ServletConfig还没有任何内容。
        // 参考了一些网上的例子: https://blog.csdn.net/u013277209/article/details/109177452
        initPropertySources();

        // Validate that all properties marked as required are resolvable:
        // see ConfigurablePropertyResolver#setRequiredProperties
        // 校验一下环境必填属性
        getEnvironment().validateRequiredProperties();

        // Store pre-refresh ApplicationListeners...
        // SpringBoot检索出来的listeners赋值给earlyApplicationListeners
        if (this.earlyApplicationListeners == null) {
            this.earlyApplicationListeners = new LinkedHashSet<>(this.applicationListeners);
        } else {
            // Reset local application listeners to pre-refresh state.
            this.applicationListeners.clear();
            this.applicationListeners.addAll(this.earlyApplicationListeners);
        }

        // Allow for the collection of early ApplicationEvents,
        // to be published once the multicaster is available...
        this.earlyApplicationEvents = new LinkedHashSet<>();
    }
```

这里有一个疑惑点，我们需要带着在后续去探索: **earlyApplicationListeners在后续会在哪里使用**

### 2.2.2 PrepareBeanFactory

```java
    /**
     * Configure the factory's standard context characteristics, such as the context's ClassLoader
     * and post-processors. beanFactory的基础配置操作
     *
     * @param beanFactory the BeanFactory to configure
     */
    protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {
        // Tell the internal bean factory to use the context's class loader etc.
        beanFactory.setBeanClassLoader(getClassLoader());
        beanFactory.setBeanExpressionResolver(
                new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));
        beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));

        // Configure the bean factory with context callbacks.
        // 添加一个bean的后置处理器，这个是内部系统操作用到的。并忽略
        beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));
        // 先按照字面意思来理解,会忽略这些接口的实现类的依赖项，但是这样讲很奇怪，因为我业务实现的这些接口的bean不可能没有依赖，这个进行忽略是为什么呢？
        beanFactory.ignoreDependencyInterface(EnvironmentAware.class);
        beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);
        beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);
        beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);
        beanFactory.ignoreDependencyInterface(MessageSourceAware.class);
        beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);

        // BeanFactory interface not registered as resolvable type in a plain factory.
        // MessageSource registered (and found for autowiring) as a bean.
        // 注册一些接口的bean，如果其他bean需要用到这些接口的实例对象，那默认就是autowiredValue
        beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);
        beanFactory.registerResolvableDependency(ResourceLoader.class, this);
        beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);
        beanFactory.registerResolvableDependency(ApplicationContext.class, this);

        // Register early post-processor for detecting inner beans as ApplicationListeners.
        // 以listener的形式注册到后置处理器来检查bean对象
        beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));

        // 注册一些默认的bean
        // Detect a LoadTimeWeaver and prepare for weaving, if found.
        // String LOAD_TIME_WEAVER_BEAN_NAME = "loadTimeWeaver";
        if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
            beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
            // Set a temporary ClassLoader for type matching.
            beanFactory.setTempClassLoader(
                    new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
        }

        // Register default environment beans.
        // String ENVIRONMENT_BEAN_NAME = "environment";
        if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {
            beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());
        }
        // String SYSTEM_PROPERTIES_BEAN_NAME = "systemProperties";
        if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {
            beanFactory.registerSingleton(
                    SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());
        }
        // String SYSTEM_ENVIRONMENT_BEAN_NAME = "systemEnvironment";
        if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {
            beanFactory.registerSingleton(
                    SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());
        }
```

这里还有一些东西是没有看的。
 ignoreDependencyInterface 从字面意思来说是可以理解的，但是我们业务中的一些业务组件也会实现这些接口，那这些业务组件的依赖怎么解决呢？

总结来看，这个prepareFactory主要是在beanFactory里注册了一些基础的配置。

### 2.2.3 PostProcessBeanFactory

```java
	/**
	 * Register ServletContextAwareProcessor.
	 * @see ServletContextAwareProcessor
	 */
	@Override
	protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {
		if (this.servletContext != null) {
			beanFactory.addBeanPostProcessor(new ServletContextAwareProcessor(this.servletContext));
			beanFactory.ignoreDependencyInterface(ServletContextAware.class);
		}
		WebApplicationContextUtils.registerWebApplicationScopes(beanFactory, this.servletContext);
		WebApplicationContextUtils.registerEnvironmentBeans(beanFactory, this.servletContext);
	}
```

### 2.2.4 InvokeBeanFactoryPostProcessors

//这一部分特别重要，因为涉及到了扫描**Application Package**, 各种Configuration、Component等。

```java
    /**
     * Instantiate and invoke all registered BeanFactoryPostProcessor beans, respecting explicit
     * order if given.
     *
     * <p>Must be called before singleton instantiation.
     */
    protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {
        PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(
                beanFactory, getBeanFactoryPostProcessors());

        // Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime
        // (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)
        if (beanFactory.getTempClassLoader() == null
                && beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
            beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
            beanFactory.setTempClassLoader(
                    new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
        }
    }
```

ConfigurationClassParser.doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass, Predicate<String> filter) 
这个方法就开始准备查找被标注的Configuration的类了。最先找到的Application类，因为这个类是最先被解析且变成BeanDefinition的。
接着就从这个源头开始，按照Annotation标注的scanPackages、ScanClasses开始拓展扫描。

SpringBean的三级缓存

```java
// 用于存放完全初始化好的 bean，从该缓存中取出的 bean 可以直接使用
private final Map<String, Object> singletonObjects = new ConcurrentHashMap<>(256);

// 单例对象工厂的cache，存放 bean 工厂对象，用于解决循环依赖
/** Cache of singleton factories: bean name to ObjectFactory. */
private final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<>(16);

/** Cache of early singleton objects: bean name to bean instance. */
// 提前曝光的单例对象的cache，存放原始的 bean 对象（尚未填充属性），用于解决循环依赖
private final Map<String, Object> earlySingletonObjects = new ConcurrentHashMap<>(16);
```



> ```java
> public abstract class AbstractBeanFactory extends FactoryBeanRegistrySupport
>         implements ConfigurableBeanFactory {
> 
>     protected <T> T doGetBean(
>             final String name,
>             @Nullable final Class<T> requiredType,
>             @Nullable final Object[] args,
>             boolean typeCheckOnly)
>             throws BeansException {
> 
>         // Eagerly check singleton cache for manually registered singletons.
>         // 先去获取一次，如果不为null，此处就会走缓存了~~
>         Object sharedInstance = getSingleton(beanName);
> 
>         // 如果不是只检查类型，那就标记这个Bean被创建了~~添加到缓存里 也就是所谓的  当前创建Bean池
>         if (!typeCheckOnly) {
>             markBeanAsCreated(beanName);
>         }
> 
>         // Create bean instance.
>         if (mbd.isSingleton()) {
> 
>             // 这个getSingleton方法不是SingletonBeanRegistry的接口方法
>             // 属于实现类DefaultSingletonBeanRegistry的一个public重载方法~~~
>             // 它的特点是在执行singletonFactory.getObject();前后会执行beforeSingletonCreation(beanName);和afterSingletonCreation(beanName);
>             // 也就是保证这个Bean在创建过程中，放入正在创建的缓存池里  可以看到它实际创建bean调用的是我们的createBean方法~~~~
>             sharedInstance =
>                     getSingleton(
>                             beanName,
>                             () -> {
>                                 try {
>                                     return createBean(beanName, mbd, args);
>                                 } catch (BeansException ex) {
>                                     destroySingleton(beanName);
>                                     throw ex;
>                                 }
>                             });
>             bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
>         }
>     }
> }
> 
> // 抽象方法createBean所在地  这个接口方法是属于抽象父类AbstractBeanFactory的   实现在这个抽象类里
> public abstract class AbstractAutowireCapableBeanFactory extends AbstractBeanFactory
>         implements AutowireCapableBeanFactory {
> 
>     protected Object doCreateBean(
>             final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)
>             throws BeanCreationException {
> 
>         // 创建Bean对象，并且将对象包裹在BeanWrapper 中
>         instanceWrapper = createBeanInstance(beanName, mbd, args);
>         // 再从Wrapper中把Bean原始对象（非代理~~~）  这个时候这个Bean就有地址值了，就能被引用了~~~
>         // 注意：此处是原始对象，这点非常的重要
>         final Object bean = instanceWrapper.getWrappedInstance();
> 
>         // earlySingletonExposure 用于表示是否”提前暴露“原始对象的引用，用于解决循环依赖。
>         // 对于单例Bean，该变量一般为 true   但你也可以通过属性allowCircularReferences = false来关闭循环引用
>         // isSingletonCurrentlyInCreation(beanName) 表示当前bean必须在创建中才行
>         boolean earlySingletonExposure =
>                 (mbd.isSingleton()
>                         && this.allowCircularReferences
>                         && isSingletonCurrentlyInCreation(beanName));
>         if (earlySingletonExposure) {
>             if (logger.isTraceEnabled()) {
>                 logger.trace(
>                         "Eagerly caching bean '"
>                                 + beanName
>                                 + "' to allow for resolving potential circular references");
>             }
>             // 上面讲过调用此方法放进一个ObjectFactory，二级缓存会对应删除的
>             // getEarlyBeanReference的作用：调用SmartInstantiationAwareBeanPostProcessor.getEarlyBeanReference()这个方法  否则啥都不做
>             // 也就是给调用者个机会，自己去实现暴露这个bean的应用的逻辑~~~
>             // 比如在getEarlyBeanReference()里可以实现AOP的逻辑~~~  参考自动代理创建器AbstractAutoProxyCreator
>             // 实现了这个方法来创建代理对象
>             // 若不需要执行AOP的逻辑，直接返回Bean
>             addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));
>         }
>         Object exposedObject = bean; // exposedObject 是最终返回的对象
> 
>         // 填充属于，解决@Autowired依赖~
>         populateBean(beanName, mbd, instanceWrapper);
>         // 执行初始化回调方法们~~~
>         exposedObject = initializeBean(beanName, exposedObject, mbd);
> 
>         // earlySingletonExposure：如果你的bean允许被早期暴露出去 也就是说可以被循环引用  那这里就会进行检查
>         // 此段代码非常重要~~~~~但大多数人都忽略了它
>         if (earlySingletonExposure) {
>             // 此时一级缓存肯定还没数据，但是呢此时候二级缓存earlySingletonObjects也没数据
>             // 注意，注意：第二参数为false  表示不会再去三级缓存里查了~~~
> 
>             // 此处非常巧妙的一点：：：因为上面各式各样的实例化、初始化的后置处理器都执行了，如果你在上面执行了这一句
>             //  ((ConfigurableListableBeanFactory)this.beanFactory).registerSingleton(beanName,
>             // bean);
>             // 那么此处得到的earlySingletonReference 的引用最终会是你手动放进去的Bean最终返回，完美的实现了"偷天换日" 特别适合中间件的设计
>             // 我们知道，执行完此doCreateBean后执行addSingleton()  其实就是把自己再添加一次  **再一次强调，完美实现偷天换日**
>             Object earlySingletonReference = getSingleton(beanName, false);
>             if (earlySingletonReference != null) {
> 
>                 // 这个意思是如果经过了initializeBean()后，exposedObject还是木有变，那就可以大胆放心的返回了
>                 // initializeBean会调用后置处理器，这个时候可以生成一个代理对象，那这个时候它哥俩就不会相等了 走else去判断吧
>                 if (exposedObject == bean) {
>                     exposedObject = earlySingletonReference;
>                 }
> 
>                 // allowRawInjectionDespiteWrapping这个值默认是false
>                 // hasDependentBean：若它有依赖的bean 那就需要继续校验了~~~(若没有依赖的 就放过它~)
>                 else if (!this.allowRawInjectionDespiteWrapping && hasDependentBean(beanName)) {
>                     // 拿到它所依赖的Bean们~~~~ 下面会遍历一个一个的去看~~
>                     String[] dependentBeans = getDependentBeans(beanName);
>                     Set<String> actualDependentBeans = new LinkedHashSet<>(dependentBeans.length);
> 
>                     // 一个个检查它所以Bean
>                     // removeSingletonIfCreatedForTypeCheckOnly这个放见下面  在AbstractBeanFactory里面
>                     // 简单的说，它如果判断到该dependentBean并没有在创建中的了的情况下,那就把它从所有缓存中移除~~~  并且返回true
>                     // 否则（比如确实在创建中） 那就返回false 进入我们的if里面~  表示所谓的真正依赖
>                     // （解释：就是真的需要依赖它先实例化，才能实例化自己的依赖）
>                     for (String dependentBean : dependentBeans) {
>                         if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {
>                             actualDependentBeans.add(dependentBean);
>                         }
>                     }
> 
>                     // 若存在真正依赖，那就报错（不要等到内存移除你才报错，那是非常不友好的）
>                     // 这个异常是BeanCurrentlyInCreationException，报错日志也稍微留意一下，方便定位错误~~~~
>                     if (!actualDependentBeans.isEmpty()) {
>                         throw new BeanCurrentlyInCreationException(
>                                 beanName,
>                                 "Bean with name '"
>                                         + beanName
>                                         + "' has been injected into other beans ["
>                                         + StringUtils.collectionToCommaDelimitedString(
>                                                 actualDependentBeans)
>                                         + "] in its raw version as part of a circular reference, but has eventually been "
>                                         + "wrapped. This means that said other beans do not use the final version of the "
>                                         + "bean. This is often the result of over-eager type matching - consider using "
>                                         + "'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example.");
>                     }
>                 }
>             }
>         }
> 
>         return exposedObject;
>     }
> 
>     // 虽然是remove方法 但是它的返回值也非常重要
>     // 该方法唯一调用的地方就是循环依赖的最后检查处~~~~~
>     protected boolean removeSingletonIfCreatedForTypeCheckOnly(String beanName) {
>         // 如果这个bean不在创建中  比如是ForTypeCheckOnly的  那就移除掉
>         if (!this.alreadyCreated.contains(beanName)) {
>             removeSingleton(beanName);
>             return true;
>         } else {
>             return false;
>         }
>     }
> }
> ```



